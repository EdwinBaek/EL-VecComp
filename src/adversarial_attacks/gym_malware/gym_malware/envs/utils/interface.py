import os
import re
import sys
import glob
import gzip
import json
import hashlib
import requests
import numpy as np
from sklearn.externals import joblib
from gym_malware.envs.utils.pefeatures import PEFeatureExtractor
module_path = os.path.dirname(os.path.abspath(sys.modules[__name__].__file__))
SAMPLE_PATH = os.path.join(module_path, 'samples')
try:
    # for RESTful interface to remote model
    __private_data = json.load(open(os.path.join(module_path, 'params.json'), 'r'))
except FileNotFoundError:
    # if you want to use the cloud interface, you must populate your own params.json
    # file.  Look at params.json.in for a template, which takes the following form
    __private_data = {
          "url": "http://my.av.api", # route to RESTful API interface
          "username": "username",    # Username
          "password": "password",    # password
          "version": "1.0",          # version
          "threshold": 0.90          # threshold
    }
    # you may also need to change get_score_remote and/or get_label_remote below

# for local model
feature_extractor =  PEFeatureExtractor()

local_model = joblib.load(os.path.join(module_path, 'gradient_boosting.pkl') )

# 모델 형태 확인
if isinstance(local_model, np.ndarray):
    print("Loaded model is a numpy array")
    expected_features = local_model.shape[1]  # 배열의 열 수를 특성 수로 가정
else:
    print("Loaded model is a scikit-learn model")
    if hasattr(local_model, 'n_features_'):
        expected_features = local_model.n_features_
    elif hasattr(local_model, 'n_features_in_'):
        expected_features = local_model.n_features_in_
    else:
        expected_features = local_model.feature_importances_.shape[0]

actual_features = feature_extractor.dim

print(f"Model expects {expected_features} features")
print(f"Feature extractor provides {actual_features} features")

if expected_features != actual_features:
    print("Warning: Feature mismatch detected. Proceeding with caution.")
    # 여기서 에러를 발생시키지 않고 경고만 출력합니다.
    # 새 모델 학습을 위해 계속 진행할 수 있도록 합니다.

local_model_threshold = 0.90

class FileProcessor:
    def __init__(self, sample_path=SAMPLE_PATH):
        self.sample_path = sample_path

    def is_valid_md5(self, filename):
        """MD5 형식의 파일명인지 확인 (32자의 16진수)"""
        return bool(re.match(r'^[0-9a-fA-F]{32}$', filename))

    def is_valid_sha256(self, filename):
        """SHA256 형식의 파일명인지 확인 (64자의 16진수)"""
        return bool(re.match(r'^[0-9a-fA-F]{64}$', filename))

    def get_available_hashes(self, hash_type='both'):
        """지정된 디렉토리에서 MD5 또는 SHA256 형식의 파일명 목록 반환"""
        hash_list = []
        for fp in glob.glob(os.path.join(self.sample_path, '*')):
            fn = os.path.split(fp)[-1]

            if hash_type == 'md5' and self.is_valid_md5(fn):
                hash_list.append(fn)
            elif hash_type == 'sha256' and self.is_valid_sha256(fn):
                hash_list.append(fn)
            elif hash_type == 'both' and (self.is_valid_md5(fn) or self.is_valid_sha256(fn)):
                hash_list.append(fn)

        assert len(hash_list) > 0, f"No files found in {self.sample_path} with specified hash format"
        return hash_list

    def fetch_file(self, file_hash):
        """해시값에 해당하는 파일 내용 반환"""
        location = os.path.join(self.sample_path, file_hash)
        try:
            with open(location, 'rb') as infile:
                bytez = infile.read()
        except IOError:
            raise FileRetrievalFailure(
                f"Unable to read file with hash {file_hash} from {location}")
        return bytez

    def md5_to_sha256(self, bytez):
        """파일 내용의 SHA256 해시값 계산"""
        m = hashlib.sha256()
        m.update(bytez)
        return m.hexdigest()

    def get_sha256_for_md5(self, md5_hash):
        """MD5 해시에 해당하는 파일의 SHA256 해시값 반환"""
        bytez = self.fetch_file(md5_hash)
        return self.md5_to_sha256(bytez)

class ClassificationFailure(Exception):
    pass


class FileRetrievalFailure(Exception):
    pass


# 원래 argument는 sha256 이었음
def fetch_file(file_hash):
    # Original code
    # location = os.path.join(SAMPLE_PATH, sha256)
    # try:
    #     with open(location, 'rb') as infile:
    #         bytez = infile.read()
    # except IOError:
    #     raise FileRetrievalFailure(
    #         "Unable to read sha256 from {}".format(location))
    #
    # return bytez

    processor = FileProcessor(SAMPLE_PATH)
    # 입력이 MD5인 경우에도 처리
    if len(file_hash) == 32:  # MD5 hash
        return processor.fetch_file(file_hash)
    else:  # SHA256 hash
        # SHA256에 해당하는 MD5 파일 찾기
        md5_files = processor.get_available_hashes(hash_type='md5')
        for md5_hash in md5_files:
            if processor.get_sha256_for_md5(md5_hash) == file_hash:
                return processor.fetch_file(md5_hash)
        raise FileRetrievalFailure(f"No corresponding file found for SHA256: {file_hash}")


def get_available_sha256():
    # Original code
    # sha256list = []
    # for fp in glob.glob(os.path.join(SAMPLE_PATH, '*')):
    #     fn = os.path.split(fp)[-1]
    #     result = re.match(r'^[0-9a-fA-F]{64}$', fn) # require filenames to be sha256
    #     if result:
    #         sha256list.append(result.group(0))
    # assert len(sha256list)>0, "no files found in {} with sha256 names".format( SAMPLE_PATH )
    # return sha256list

    processor = FileProcessor(SAMPLE_PATH)
    # MD5 파일들을 가져와서 SHA256으로 변환
    md5_files = processor.get_available_hashes(hash_type='md5')
    sha256_list = []
    for md5_hash in md5_files:
        bytez = processor.fetch_file(md5_hash)
        sha256_list.append(processor.md5_to_sha256(bytez))
    return sha256_list

# modify this function to git a remote API of your choice
# note that in this example, the API route expects version specification
# in addition to authentication username and password
def get_score_remote(bytez):
    try:
        response = requests.post(__private_data['url'],
                                 params={'version': __private_data['version']},
                                 auth=(__private_data['username'],
                                       __private_data['password']),
                                 headers={
                                     'Content-Type': 'application/octet-stream'},
                                 data=bytez)
    except ConnectionError:
        print("Bad route for hitting remote AV via RESTful interface. Please modify params.json (see params.json.in).")
        raise

    if not response.ok:
        raise(ClassificationFailure("Unable to get label for query"))
    json_response = response.json()
    if not 'data' in json_response or not 'score' in json_response['data']:
        raise(ClassificationFailure(
            "Can't find ['data']['score'] in response"))
    # mimic black box by thresholding here
    return json_response['data']['score']


def get_label_remote(bytez):
    # mimic black box by thresholding here
    return float( get_score_remote(bytez) >= __private_data['threshold'] )


def get_score_local(bytez):
    # extract features
    features = feature_extractor.extract(bytez)

    # query the model
    if isinstance(local_model, np.ndarray):
        # 만약 local_model이 numpy 배열이라면, 직접 계산을 수행해야 합니다.
        # 이는 임시 방편이며, 실제 사용 중인 모델의 동작을 반영해야 합니다.
        score = np.dot(features, local_model.T)[0]
    else:
        # scikit-learn 모델인 경우
        score = local_model.predict_proba(features.reshape(1,-1))[0,-1]

    return score

def get_label_local(bytez):
    # mimic black box by thresholding here
    score = get_score_local(bytez)
    label = float( get_score_local(bytez) >= local_model_threshold )
    print("score={} (hidden), label={}".format(score,label)) 
    return label
